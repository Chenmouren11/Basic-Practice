1.在接到这个票的第一时间我就是根据票里的复现方法去复现这个bug，具体步骤为先通过FG4将手机版本刷为61.1.A.5.150在side sense menu当中添加一些shortcut和其他的，然后又通过FG4将手机版本刷为61.2.A.0.194并选择keep data，刷机后开机发现shortcut不见了而其他的数据得以保留。到此复现bug成功。

2.在拿到这个bug的第一时间我的想法就是先找到保存shortcut数据的具体位置，然后看看刷机前后保存的shortcut数据有没有什么变化，依据这个思路我很快的发现了保存shortcut数据和普通的customList数据保存在一起，都是存放在应用的SharePreference当中，通过再次尝试我发现在从s升级的到t版本后的第一次开机后，SharePreference当中记录shortcut数据就消失不见了。到此我找到了shortcut数据丢失的本质就是SharePreference当中记录被删除了。

3.到调查进行到这一步我我也发现了一个非常严重的问题，那就是我虽然知道从s升级到t之后SharePreference当中记录shortcut数据会被删除，但是我不知道在具体是在那个位置被修改的，同时我发现我也不能在我要的地方打印日志以此来确定删除数据的具体代码，这就非常难受了。这时我询问了我的导师，但是因为问题发生在版本升级之后，导师其实也没有什么好的办法可以快速找到问题所在的办法，只能老老实实的看代码确定问题所在。

4.在看T版本代码的过程中我发现能够自发修改保存在sharedPreferences文件中的custom_list数据方法只有可能是在第一次使用sidesense时调用的setFixCustomApp(context)和在服务中不断更新ShortcutsList的updateCustomap（）两个方法，但是应为在每次通过FG4flash T software(64.1.A.0.432)后，开机的一时间sharedPreferences文件中的custom_list数据就一已经被修改，因此很难判断是那个方法修改了数据，也很难验证上述推断是否正确。在这时我还没有想到好的测试方法，只能根据代码去推测可能发生问题的位置。

5.在仅仅是看T版本的代码不能解决问题后，我想到了通过对比对比T版本代码和S版本代码的差别来确定问题所在，通过对比两个版的代码的不同，还真让我发现了两处可疑的地方，这时难于测试的问题又摆在了我的面前，在遇到困难时我有发动了问导师的技能，导师这次也给了我一个很不错的测试方法，即将S版本可疑处的代码修改成T版本代码的样子，将修改后的代码进行打包安装，然后在升级为T版本代码，观察升级后的情况，如果不在发生bug就说明是可疑代码处导致bug，如果依然发生就基本可以排除可疑代码的嫌疑。

6.通过导师提供的测试方法进行过尝试后，发现依旧会发生bug，这个时候的我比较沮丧，因为通过这种方法依旧没能确定导致bug发生的具体位置，只是排除了可疑代码的嫌疑，其他的却没有更多的收获。但是在不断刷机切换版本的过程中，我也发现了一点很奇怪的地方，那就是并不是每次刷机后开机都重新安装Sidesense而是只有在从S版本升级到T版本后开机才会重新安装Sidesense,通过和导师的交流，我了解到一般只有在版本差异过大时系统才会重新安装系统预装的Sidesense，通过更深入的调查我知道了，在开机时系统的PackageManager会自动检查当前的安装的软件版本和系统预安装软件版本，如果当前版本过低，就会安装较新的版本。

7.在了解到这些知识后，我产生了一些大胆的想法，就是将T版本的Sidesense apk安装到S版本的系统当中，我最初的想法是这样做后看看是否会发生bug，最好同时能够输出自己想要的日志。在第一次使用Push命令然后reboot死机后我是有点慌得，当时手机的指示灯都不会亮了，我还以为是把手机给烧坏了，还是在求助导师之后才又重新把把手机点亮了，同时通过这次尝试我也知道了，S版本的apk和T版本的apk所依赖的SDK环境是不相同的，因此在S版本的系统上是不能运行依赖高版本SDK的T版本apk，程序会直接崩溃，开机的话也会开不了机。但是当时我还是不死心的用install命令尝试了安装一遍Sidesense希望能够在不用重启的情况下安装T版本的Sidesense可以重现bug并观察到日志，但是在安装结束后手机上的Sidesense直接crash了，怎么都打不开了，同时，查看SharePreference当中的数据也没有任何变化，可以说这是此尝试比较失败。但当时我也没想正是这样一步帮我为解决bug迈出了一大步。

8.当时我也不算失落，正准备进行下一步尝试在T版本当中安装S版本的apk再安装T版本的apk看看能否复现bug，如果成功这样也能输出想要的日志。可是在刚刚将手机版本从S版本升级到T版本后，日常观察是否有bug出现日志时，我惊奇的发现开机时居然输出了我在代码中写的日志，这时我才真正反应过来，在S版本上安装T版本的apk虽然会崩溃，但是apk是保存了下来，在升级到T版本后apk却不用更新。虽然发现了这个可行的验证方法，但我还是坚持对正准备尝试的方法进行了验证，毕竟老是把版本刷来刷去验证很慢。但是结果却让我比较失望，通过再T版本安装S版本的apk再安装回T版本的apk并不会复现bug，bug好像只会发生在S升级到T版本后的第一次开机后。

9.虽然简单的验证方法失败了，但是我还是通过在S版本上刷T版本apk然后再升级到T版本的方式在logcat当中打印出了自己的日志，通过输出的日志我首先是排查出来删除Shortcut的具体代码位置，结果让我很意外执行删除的操作的位置居然是在getAppsList()当中，这让我很意外。在找到具体位置后，我又通过？？？？？抛出调用getAppsList()的路径，发现启动getAppsList()最初的源头是系统的程序，这就排除了调用getAppsList()误删数据的可能。

10.之后我通过对getAppsList()的代码逻辑进行分析，发现想要删除shortcut就需要？？？？抛出一个null异常，继续对代码分析，发现只有当？？？？返回为null时，？？？会抛出null异常，而？？？？返回值为null这说明当前shortcut的packagName不在系统的mShortcutsList当中,而这显然是不符合逻辑的。因此我在此处进行了很多日志打印，包括在对mShortcutsList进行初始化和更新操作的？？？？？当中使用API？？？？获得系统中所有的Shortcut的前后对mShortcutsList的长度进行打印和对？？？？进行实例化的各个过程当中的各个节点状态都进行打印。通过对日志的观察，我发现造成bug的根本原因就是在S版本升级到T版本后第一次开机时，第一次调用API？？？获得系统中所有的Shortcut时会抛出一个？？？？的异常，到此我已经确定了造成bug的原因。

11.在知道造出bug的原因之后接下来就是通过尽量少的代码修改解决掉bug，因为在在第一次调用API？？？时获得ShortcutsList失败，因此我的简单解决思路就是在在调用API？？？处不断循环，直至获得的mShortcutsList长度正常，这种方法经过尝试是有效的，但是因为？？？会在多个地方会被经常调用，因此这种修改方法可能会造成更大的问题。在和？？？同事的不断研究讨论过后我们我们决定在getAppsList()当中的？？？？处添加判断条件作为解决bug的方法。首先我们尝试的时加入？？？？？，作为判断条件，希望能在Sidesense完全启动以后才能进行

？？？？？

？？？？?

但是这种方法最终失败，因为方法？？？？的调用会导致null指针异常。之后我们选择使用？？？作为判断条件，经过尝试我们发现这种方法能够有效的解决bug，同时这样修改带代码的整体影响也很小。

12.在修改好代码之后，接下来需要在本地提交代码，提交代码的需要添加？？？？信息，添加？？？信息的歌手可以参考前面的提交记录。

13.完成本地代码的提交之后，就可以将代码push的线上进行代码review了，首先需要自己review+2，之后等等待组内review+1，如果组内有commit修改，可以在线上修改之后publish edit，之后又重新开始一遍review过程，等待组内review通过后，就可以邀请客户review，等待客户review+1后就可以进行submit代码入库了。

14.master分支入场成功后，可以使用？？？？？将master分支的提交记录同步的？？？和？？？分支当中，然后对这两分支进行一遍代码review过程就完成票system-5543的全部调查。在票里添加相关comment后就可以关闭票了。

